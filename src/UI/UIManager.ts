import {MarkdownView, setIcon, WorkspaceLeaf} from 'obsidian';
import {OpenAPIPluginContext} from "../contextManager";
import {
    ButtonConfig,
    ChangeButtonLocationEvent,
    ChangeServerButtonStateEvent,
    ToggleButtonVisibilityEvent,
    UIPluginSettings
} from '../typing/interfaces'
import {
    ButtonLocation,
    eventID, RenderingMode,
    RIBBON_LOCATION,
    SERVER_ICON_NAME_OFF,
    SERVER_ICON_NAME_ON,
    STATUSBAR_LOCATION,
    TOOLBAR_LOCATION
} from "../typing/types";

/**
 * UIManager class manages the user interface elements related to OpenAPI Renderer Plugin in Obsidian.
 */
export default class UIManager {
    private buttonManager: ButtonManager;
    private buttonFactory: ButtonFactory;
    appContext!: OpenAPIPluginContext

    constructor(appContext: OpenAPIPluginContext) {
        this.appContext = appContext;
        this.buttonManager = new ButtonManager(this);
        this.buttonFactory = new ButtonFactory(this);
    }

    /**
     * Initializes the UI manager when the Obsidian workspace layout is ready.
     * Binds the `initializeUIManager` method to handle UI initialization tasks.
     */
    async initializeUI() {
        this.appContext.app.workspace.onLayoutReady(this.initializeUIManager.bind(this))
    }

    /**
     * Initializes the UI manager by creating all buttons, registering events,
     * and registering a cleanup handler for button removal.
     *
     * @private
     */
    private async initializeUIManager() {
        await this.createAllButtons();
        this.registerEvents();
        this.appContext.plugin.observer.subscribe(
            this.appContext.app.workspace,
            eventID.PowerOff,
            this.onunload
        )
    }

    private async onunload() {
        await this.buttonManager.removeAllButtons()
    }

    /**
     * Creates all buttons using configurations generated by the ButtonFactory.
     * This method fetches all button configurations and creates the buttons asynchronously.
     *
     * @private
     */
    private async createAllButtons() {
        const configs = this.buttonFactory.createAllButtonConfigs();
        await Promise.all(configs.map(config => this.buttonManager.createButton(config)));
    }

    /**
     * Updates the toolbar buttons for the given workspace leaf if it is a Markdown view.
     * Removes all existing toolbar buttons and creates new ones based on the current configurations.
     *
     * @param leaf - The workspace leaf to update the toolbar for.
     */
    private async updateToolbar(leaf: WorkspaceLeaf) {
        const isMarkdownView = leaf.view instanceof MarkdownView
        const view = leaf.view as MarkdownView

        if (!view) return

        const toolBarContainer = this.buttonManager.getToolBarContainer(view)

        if (!toolBarContainer) return;

        this.removeALlToolbarButtonsFromView(view)

        const toolbarButtons = this.buttonManager.buttons.get('toolbar');
        if (toolbarButtons) {
            const buttonPromises = Array.from(toolbarButtons)
                .map(async ([id, buttonConfig]) => {
                    if (buttonConfig.config.state) {
                        await this.buttonManager.createButton(buttonConfig.config);
                    }
                });

            await Promise.all(buttonPromises);
        }
    }

    /**
     * Registers event listeners for the UI manager.
     * - Listens for active leaf changes to update the toolbar.
     * - Subscribes to toggle button visibility and change button location events.
     */
    private registerEvents() {
        this.appContext.plugin.registerEvent(
            this.appContext.app.workspace.on('active-leaf-change', async (leaf) => {
                if (leaf?.view instanceof MarkdownView) {
                    await this.updateToolbar(leaf)
                }
            })
        );
        this.buttonManager.buttons.forEach((buttonMap) => {
            buttonMap.forEach((button) => {
                button.subscribe();
            });
        });
    }

    /**
     * Removes all toolbar buttons from the specified Markdown view.
     *
     * @param view - The Markdown view from which to remove all toolbar buttons.
     */
    private removeALlToolbarButtonsFromView(view: MarkdownView) {
        const toolbarContainer = this.buttonManager.getToolBarContainer(view)
        if (!toolbarContainer) return;
        const allToolBarButtons = toolbarContainer.querySelectorAll('.openapi-renderer-toolbar-button')
        if (allToolBarButtons) {
            allToolBarButtons.forEach(button => {
                toolbarContainer.removeChild(button)
            })
        }
    }

    /**
     * Retrieves the current UI settings from the plugin context.
     * Returns an object containing settings related to button creation and their locations.
     */
    get settings(): UIPluginSettings {
        return {
            isCreateServerButton: this.appContext.plugin.settings.isCreateServerButton,
            isCreateCommandButtons: this.appContext.plugin.settings.isCreateCommandButtons,
            serverButtonLocation: this.appContext.plugin.settings.serverButtonLocation,
            commandButtonLocation: this.appContext.plugin.settings.commandButtonLocation
        } as UIPluginSettings;
    }

    /**
     * Toggles the server's running state in response to a click event on the server button.
     * Updates the button's icon and shows a notification based on the server's new state.
     *
     * @param event - The MouseEvent object representing the click event on the server button.
     */
    async toggleServer(event: MouseEvent) {
        const button = event.currentTarget as HTMLElement;
        const isRunning = this.appContext.plugin.server.isRunning();
        const view = this.appContext.app.workspace.getActiveViewOfType(MarkdownView)

        if (isRunning) {
            const isStopped = await this.appContext.plugin.server.stop();
            this.updateServerButtonIcon(!isStopped, button);
            isStopped && this.appContext.plugin.showNotice(`Server stopped.`);
            view && this.appContext.plugin.previewHandler.rerenderPreview(view)
        } else {
            view && this.appContext.plugin.previewHandler.rerenderPreview(view)
            const isStarted = await this.appContext.plugin.server.start();
            this.updateServerButtonIcon(isStarted, button);
            const msg = isStarted ? 'Server started'
                : 'Cannot start the server... Try again'
            this.appContext.plugin.showNotice(msg)
        }
    }

    /**
     * Updates the icon of a server button based on its running state.
     *
     * @param isRunning - Indicates whether the server is currently running.
     * @param button - The HTML element of the server button to update.
     */
    updateServerButtonIcon(isRunning: boolean, button: HTMLElement) {
        const iconName = isRunning ? SERVER_ICON_NAME_ON : SERVER_ICON_NAME_OFF;
        const tooltip = isRunning ? 'Toggle OpenAPI Renderer Server Off' : 'Toggle OpenAPI Renderer Server On';
        setIcon(button, iconName)
        setIcon(button, iconName);
        button.setAttribute('aria-label', tooltip);
        button.setAttribute('data-tooltip', tooltip);
    }


}

/**
 * ButtonManager class manages the creation, visibility, and removal of buttons
 * for the UIManager in Obsidian's OpenAPI Renderer Plugin.
 */
class ButtonManager {
    buttons: Map<ButtonLocation, Map<string, Button>> = new Map();
    uiManager!: UIManager;

    constructor(uiManager: UIManager) {
        this.uiManager = uiManager;

        [RIBBON_LOCATION, STATUSBAR_LOCATION, TOOLBAR_LOCATION].forEach(location => {
            this.buttons.set(location as ButtonLocation, new Map<string, Button>());
        });
    }

    /**
     * Creates a button based on the provided configuration and adds it to the specified location.
     * Updates the button's visibility based on its initial state after creation.
     *
     * @param config - The configuration object defining the button's properties.
     */
    async createButton(config: ButtonConfig): Promise<void> {
        const buttonMap = this.buttons.get(config.location);
        if (!buttonMap) {
            return;
        }

        const htmlElement = await this.createButtonElement(config);

        if (htmlElement) {
            config.htmlElement = htmlElement;

            const buttonObject = new Button(config, this)
            buttonMap.set(config.id, buttonObject);
            this.toggleVisibility(buttonObject, config.state)
        }
    }

    /**
     * Creates an HTML element for a button based on the provided configuration.
     *
     * @param config - The configuration object defining the button's properties.
     * @returns A Promise resolving to the HTML element of the created button, or undefined if the location is invalid.
     */
    private async createButtonElement(config: ButtonConfig): Promise<HTMLElement | undefined> {
        switch (config.location) {
            case RIBBON_LOCATION:
                return this.createRibbonButtonHTMLElement(config);
            case STATUSBAR_LOCATION:
                return this.createStatusBarButtonHTMLElement(config);
            case TOOLBAR_LOCATION:
                return this.createToolBarButtonHTMLElement(config);
            default:
                return undefined;
        }
    }

    /**
     * Creates an HTML element for a ribbon button based on the provided configuration.
     *
     * @param config - The configuration object defining the button's properties.
     * @returns The HTML element of the created ribbon button.
     */
    private createRibbonButtonHTMLElement(config: ButtonConfig): HTMLElement {
        const button = this.uiManager.appContext.plugin.addRibbonIcon(config.icon, config.title, config.onClick);
        button.setAttribute('id', config.id);
        return button;
    }

    /**
     * Creates an HTML element for a status bar button based on the provided configuration.
     *
     * @param config - The configuration object defining the button's properties.
     * @returns The HTML element of the created status bar button.
     */
    private createStatusBarButtonHTMLElement(config: ButtonConfig): HTMLElement {
        const button = this.uiManager.appContext.plugin.addStatusBarItem();
        setIcon(button, config.icon);
        button.setAttribute('aria-label', config.title);
        button.setAttribute('id', config.id);
        button.addEventListener('click', config.onClick);
        return button;
    }

    /**
     * Creates an HTML element for a toolbar button based on the provided configuration.
     *
     * @param config - The configuration object defining the button's properties.
     * @returns The HTML element of the created toolbar button.
     */
    private createToolBarButtonHTMLElement(config: ButtonConfig): HTMLElement {
        const button = document.createElement("button");
        button.className = `${config.id}-button clickable-icon view-action openapi-renderer-toolbar-button`;
        setIcon(button, config.icon);
        button.setAttribute('aria-label', config.title);
        button.setAttribute('id', config.id);
        button.addEventListener('click', config.onClick);
        const view = this.uiManager.appContext.app.workspace.getActiveViewOfType(MarkdownView)
        const toolbarContainer = view && this.getToolBarContainer(view)
        if (toolbarContainer) {
            toolbarContainer.prepend(button);
        }
        return button;
    }

    /**
     * Retrieves the toolbar container element from the specified Markdown view.
     *
     * @param view - The Markdown view from which to retrieve the toolbar container.
     * @returns The toolbar container element if found, otherwise null.
     */
    getToolBarContainer(view: MarkdownView | null): Element | null {
        if (view) {
            return view.containerEl.querySelector(".view-header .view-actions");
        }
        return null
    }


    /**
     * Updates the visibility of a button based on its location and ID.
     *
     * @param location - The location of the button (e.g., `ribbon`, `statusbar`, `toolbar`).
     * @param id - The ID of the button to update.
     */
    updateButtonVisibilityByLocationAndID(location: ButtonLocation, id: string) {
        const config = this.buttons.get(location)?.get(id);
        if (config) {
            this.toggleVisibility(config, config.config.state);
        }
    }

    /**
     * Toggles the visibility of a button based on the specified state.
     *
     * @param config - The configuration object of the button.
     * @param isVisible - Indicates whether the button should be visible (`true`) or hidden (`false`).
     *                    If `true`, sets the button's display style to 'block'; otherwise, sets it to `none`.
     */
    private toggleVisibility(config: Button, isVisible: boolean) {
        const button = config.config.htmlElement
        if (button) {
            setTimeout(() => {
                button.style.setProperty('display', isVisible ? 'block' : 'none', 'important');
            }, 0);
        }
    }


    /**
     * Removes all buttons from their respective locations.
     * Clears the internal button map after removal.
     */
    async removeAllButtons() {
        this.buttons.forEach((buttonMap) => {
            buttonMap.forEach((button) => {
                button.config.htmlElement?.remove()
            })
        })
        this.buttons.clear()
    }

    // async updateButtonsVisibility() {
    //     for (const [location, buttonMap] of this.buttons) {
    //         for (const config of buttonMap.values()) {
    //             const isVisible = config.config.state
    //             this.toggleVisibility(config as Button, isVisible);
    //         }
    //     }
    // }
}

/**
 * ButtonFactory class handles the creation of button configurations
 * for different locations (ribbon, statusbar, toolbar) in UIManager.
 */
class ButtonFactory {
    uiManager: UIManager;

    constructor(uiManager: UIManager) {
        this.uiManager = uiManager;
    }

    /**
     * Creates an array of all button configurations for different locations.
     *
     * @returns An array of ButtonConfig objects representing all button configurations.
     */
    createAllButtonConfigs(): ButtonConfig[] {
        const allConfigs: ButtonConfig[] = [];
        const locations: ButtonLocation[] = ['ribbon', 'statusbar', 'toolbar'];

        for (const location of locations) {
            allConfigs.push(this.createServerButtonConfig(location, this));
            allConfigs.push(this.createRenderButtonConfig(location, this));
            allConfigs.push(this.createRefreshButtonConfig(location, this));
        }
        return allConfigs;
    }

    /**
     * Creates a configuration object for the server toggle button.
     *
     * @param location - The location where the button will be placed (e.g., 'ribbon', 'statusbar', 'toolbar').
     * @param buttonFactory - The ButtonFactory instance managing button creation.
     * @returns A ButtonConfig object representing the server toggle button configuration.
     */
    private createServerButtonConfig(location: ButtonLocation, buttonFactory: ButtonFactory): ButtonConfig {
        return {
            id: `openapi-renderer-server`,
            get icon() {
                return buttonFactory.uiManager.appContext.plugin.server.isRunning() ? SERVER_ICON_NAME_ON : SERVER_ICON_NAME_OFF;
            },
            title: 'Toggle OpenAPI Renderer Server',
            onClick: (event: MouseEvent) => this.uiManager.toggleServer(event),
            location: location,
            htmlElement: undefined,
            get state() {
                const isMarkdownView = buttonFactory.uiManager.appContext.app.workspace.getLeaf()?.view instanceof MarkdownView;
                const isCreationAllowedNow = buttonFactory.uiManager.settings.isCreateServerButton
                const isCorrectLocation = buttonFactory.uiManager.settings.serverButtonLocation === location;
                const isVisibleInCurrentView = location === 'ribbon' || isMarkdownView
                return isCreationAllowedNow && isCorrectLocation && isVisibleInCurrentView;
            },
            buttonType: 'server-button'
        };
    }

    /**
     * Creates a configuration object for the render Swagger UI button.
     *
     * @param location - The location where the button will be placed (e.g., 'ribbon', 'statusbar', 'toolbar').
     * @param buttonFactory - The ButtonFactory instance managing button creation.
     * @returns A ButtonConfig object representing the render Swagger UI button configuration.
     */
    private createRenderButtonConfig(location: ButtonLocation, buttonFactory: ButtonFactory): ButtonConfig {
        return {
            id: `openapi-renderer`,
            icon: 'file-scan',
            title: 'Render Swagger UI',
            onClick: async () => {
                const view = buttonFactory.uiManager.appContext.app.workspace.getActiveViewOfType(MarkdownView);
                await this.uiManager.appContext.plugin.renderOpenAPI(view!, RenderingMode.Inline);
            },
            location: location,
            htmlElement: undefined,
            get state() {
                const isMarkdownView = buttonFactory.uiManager.appContext.app.workspace.getLeaf()?.view instanceof MarkdownView;
                const isCreationAllowedNow = buttonFactory.uiManager.settings.isCreateCommandButtons
                const isCorrectLocation = buttonFactory.uiManager.settings.commandButtonLocation === location;
                const isVisibleInCurrentView = location === 'ribbon' || isMarkdownView
                return isCreationAllowedNow && isCorrectLocation && isVisibleInCurrentView;
            },
            buttonType: 'command-button'
        };
    }

    /**
     * Creates a configuration object for the refresh Swagger UI button.
     *
     * @param location - The location where the button will be placed (e.g., 'ribbon', 'statusbar', 'toolbar').
     * @param buttonFactory - The ButtonFactory instance managing button creation.
     * @returns A ButtonConfig object representing the refresh Swagger UI button configuration.
     */
    private createRefreshButtonConfig(location: ButtonLocation, buttonFactory: ButtonFactory): ButtonConfig {
        return {
            id: `openapi-refresher`,
            icon: 'refresh-ccw',
            title: 'Refresh Swagger UI',
            onClick: async () => {
                const view = buttonFactory.uiManager.appContext.app.workspace.getActiveViewOfType(MarkdownView);
                await this.uiManager.appContext.plugin.refreshOpenAPI(view!);
            },
            location: location,
            htmlElement: undefined,
            get state() {
                const isMarkdownView = buttonFactory.uiManager.appContext.app.workspace.getLeaf()?.view instanceof MarkdownView;

                const isCreationAllowedNow = buttonFactory.uiManager.settings.isCreateCommandButtons
                const isCorrectLocation = buttonFactory.uiManager.settings.commandButtonLocation === location;
                const isVisibleInCurrentView = location === 'ribbon' || isMarkdownView
                return isCreationAllowedNow && isCorrectLocation && isVisibleInCurrentView;
            },
            buttonType: 'command-button'
        };
    }
}

/**
 * Represents an abstract button object.
 * @abstract
 */
abstract class AbstractButtonObject {

    constructor(public config: ButtonConfig, public buttonManager: ButtonManager) {
        this.config = config
        this.buttonManager = buttonManager
    }

    /**
     * Subscribes the button object to events or interactions.
     * Must be implemented by subclasses.
     * @abstract
     */
    abstract subscribe(): void;
}

class Button extends AbstractButtonObject {
    constructor(config: ButtonConfig, buttonManager: ButtonManager) {
        super(config, buttonManager);
    }

    /**
     * Subscribes to various events for button behavior management.
     * - Subscribes to `ChangeButtonLocation` event to handle button location changes.
     * - Subscribes to `ToggleButtonVisibility` event to handle button visibility toggles.
     * - Subscribes to `ChangeServerButtonState` event if `buttonType` is 'server-button',
     *   to handle server button state changes.
     */
    subscribe() {
        debugger
        this.buttonManager.uiManager.appContext.plugin.observer.subscribe(
            this.buttonManager.uiManager.appContext.app.workspace,
            eventID.ChangeButtonLocation,
            this.changeButtonLocationHandler.bind(this)
        )

        this.buttonManager.uiManager.appContext.plugin.observer.subscribe(
            this.buttonManager.uiManager.appContext.app.workspace,
            eventID.ToggleButtonVisibility,
            this.toggleButtonVisibilityHandler.bind(this)
        )

        if (this.config.buttonType === 'server-button') {
            this.buttonManager.uiManager.appContext.plugin.observer.subscribe(
                this.buttonManager.uiManager.appContext.app.workspace,
                eventID.ServerStarted,
                this.serverButtonChangeStateHandler.bind(this)
            )
        }
    }

    /**
     * Handles the event when the server button state changes.
     * If the event data location matches the configured location,
     * updates the icon of the specified HTML element with the configured icon.
     * @param event The `ChangeServerButtonStateEvent` containing the event data.
     */
    private async serverButtonChangeStateHandler(event: ChangeServerButtonStateEvent) {
        if (this.config.location === event?.data.location) {
            let serverStarted = this.buttonManager.uiManager.appContext.plugin.server.isRunning()
            console.log(serverStarted)
            let icon = this.config.icon
            console.log(icon)
            let htmlElement = this.config.htmlElement
            if (htmlElement) {
                setIcon(htmlElement, this.config.icon)
            }
        }
    }

    /**
     * Handles the event when the button location changes.
     * Updates button visibility based on the old and new locations and button ID.
     * @param event The `ChangeButtonLocationEvent` containing the event data.
     */
    private async changeButtonLocationHandler(event: ChangeButtonLocationEvent) {
        this.buttonManager.updateButtonVisibilityByLocationAndID(event.data.oldLocation, event.data.buttonID)
        this.buttonManager.updateButtonVisibilityByLocationAndID(event.data.location, event.data.buttonID)
    }

    /**
     * Handles the event when the button visibility is toggled.
     * Updates button visibility based on the event's location and button ID.
     * @param event The `ToggleButtonVisibilityEvent` containing the event data.
     */
    private async toggleButtonVisibilityHandler(event: ToggleButtonVisibilityEvent) {
        debugger
        this.buttonManager.updateButtonVisibilityByLocationAndID(event.data.location, event.data.buttonID)
    }

}