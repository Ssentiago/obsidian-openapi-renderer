import {MarkdownView, setIcon, WorkspaceLeaf} from 'obsidian';
import {OpenAPIPluginContext} from "../contextManager";
import {UIPluginSettings} from '../typing/interfaces'
import {eventID, SERVER_ICON_NAME_OFF, SERVER_ICON_NAME_ON} from "../typing/types";
import {ButtonFactory} from "./buttonFactory";
import {ButtonManager} from "./buttonManager";

/**
 * UIManager class manages the user interface elements related to OpenAPI Renderer Plugin in Obsidian.
 */
export default class UIManager {
    private buttonManager: ButtonManager;
    private buttonFactory: ButtonFactory;
    appContext!: OpenAPIPluginContext

    constructor(appContext: OpenAPIPluginContext) {
        this.appContext = appContext;
        this.buttonManager = new ButtonManager(this);
        this.buttonFactory = new ButtonFactory(this);
    }

    /**
     * Initializes the UI manager when the Obsidian workspace layout is ready.
     * Binds the `initializeUIManager` method to handle UI initialization tasks.
     */
    async initializeUI() {
        this.appContext.app.workspace.onLayoutReady(this.initializeUIManager.bind(this))
    }

    /**
     * Initializes the UI manager by creating all buttons, registering events,
     * and registering a cleanup handler for button removal.
     *
     * @private
     */
    private async initializeUIManager() {
        await this.createAllButtons();
        this.registerEvents();
        this.appContext.plugin.observer.subscribe(
            this.appContext.app.workspace,
            eventID.PowerOff,
            this.onunload
        )
    }

    private async onunload() {
        await this.buttonManager.removeAllButtons()
    }

    /**
     * Creates all buttons using configurations generated by the ButtonFactory.
     * This method fetches all button configurations and creates the buttons asynchronously.
     *
     * @private
     */
    private async createAllButtons() {
        const configs = this.buttonFactory.createAllButtonConfigs();
        await Promise.all(configs.map(config => this.buttonManager.createButton(config)));
    }

    /**
     * Updates the toolbar buttons for the given workspace leaf if it is a Markdown view.
     * Removes all existing toolbar buttons and creates new ones based on the current configurations.
     *
     * @param leaf - The workspace leaf to update the toolbar for.
     */
    private async updateToolbar(leaf: WorkspaceLeaf) {
        const isMarkdownView = leaf.view instanceof MarkdownView
        const view = leaf.view as MarkdownView

        if (!view) return

        const toolBarContainer = this.buttonManager.getToolBarContainer(view)

        if (!toolBarContainer) return;

        this.removeALlToolbarButtonsFromView(view)

        const toolbarButtons = this.buttonManager.buttons.get('toolbar');
        if (toolbarButtons) {
            const buttonPromises = Array.from(toolbarButtons)
                .map(async ([id, buttonConfig]) => {
                    if (buttonConfig.config.state) {
                        await this.buttonManager.createButton(buttonConfig.config);
                    }
                });

            await Promise.all(buttonPromises);
        }
    }

    /**
     * Registers event listeners for the UI manager.
     * - Listens for active leaf changes to update the toolbar.
     * - Subscribes to toggle button visibility and change button location events.
     */
    private registerEvents() {
        this.appContext.plugin.registerEvent(
            this.appContext.app.workspace.on('active-leaf-change', async (leaf) => {
                if (leaf?.view instanceof MarkdownView) {
                    await this.updateToolbar(leaf)
                }
            })
        );
        this.buttonManager.buttons.forEach((buttonMap) => {
            buttonMap.forEach((button) => {
                button.subscribe();
            });
        });
    }

    /**
     * Removes all toolbar buttons from the specified Markdown view.
     *
     * @param view - The Markdown view from which to remove all toolbar buttons.
     */
    private removeALlToolbarButtonsFromView(view: MarkdownView) {
        const toolbarContainer = this.buttonManager.getToolBarContainer(view)
        if (!toolbarContainer) return;
        const allToolBarButtons = toolbarContainer.querySelectorAll('.openapi-renderer-toolbar-button')
        if (allToolBarButtons) {
            allToolBarButtons.forEach(button => {
                toolbarContainer.removeChild(button)
            })
        }
    }

    /**
     * Retrieves the current UI settings from the plugin context.
     * Returns an object containing settings related to button creation and their locations.
     */
    get settings(): UIPluginSettings {
        return {
            isCreateServerButton: this.appContext.plugin.settings.isCreateServerButton,
            isCreateCommandButtons: this.appContext.plugin.settings.isCreateCommandButtons,
            serverButtonLocation: this.appContext.plugin.settings.serverButtonLocation,
            commandButtonLocation: this.appContext.plugin.settings.commandButtonLocation
        } as UIPluginSettings;
    }

    /**
     * Toggles the server's running state in response to a click event on the server button.
     * Updates the button's icon and shows a notification based on the server's new state.
     *
     * @param event - The MouseEvent object representing the click event on the server button.
     */
    async toggleServer(event: MouseEvent) {
        const button = event.currentTarget as HTMLElement;
        const isRunning = this.appContext.plugin.server.isRunning();
        const view = this.appContext.app.workspace.getActiveViewOfType(MarkdownView)

        if (isRunning) {
            const isStopped = await this.appContext.plugin.server.stop();
            this.updateServerButtonIcon(!isStopped, button);
            isStopped && this.appContext.plugin.showNotice(`Server stopped.`);
            view && this.appContext.plugin.previewHandler.rerenderPreview(view)
        } else {
            view && this.appContext.plugin.previewHandler.rerenderPreview(view)
            const isStarted = await this.appContext.plugin.server.start();
            this.updateServerButtonIcon(isStarted, button);
            const msg = isStarted ? 'Server started'
                : 'Cannot start the server... Try again'
            this.appContext.plugin.showNotice(msg)
        }
    }

    /**
     * Updates the icon of a server button based on its running state.
     *
     * @param isRunning - Indicates whether the server is currently running.
     * @param button - The HTML element of the server button to update.
     */
    updateServerButtonIcon(isRunning: boolean, button: HTMLElement) {
        const iconName = isRunning ? SERVER_ICON_NAME_ON : SERVER_ICON_NAME_OFF;
        const tooltip = isRunning ? 'Toggle OpenAPI Renderer Server Off' : 'Toggle OpenAPI Renderer Server On';
        setIcon(button, iconName)
        setIcon(button, iconName);
        button.setAttribute('aria-label', tooltip);
        button.setAttribute('data-tooltip', tooltip);
    }


}

